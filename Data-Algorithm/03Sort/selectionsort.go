//* 选择排序 */
//* 1. 从当前元素起，记录当前初始循环索引（i），当当前索引值依次与索引值+1进行对比，如后者比前者小，则记录其索引下标，并将其值赋予给初始循环索引*/
//* 2. 对于下次循环则为 外部初始循环索引i++ ，且内部循环索引为初始循环索引 （i）+1，然后再求最小值。
//* 3. 对所有元素均重复以上步骤，直至最后一个元素 */
package main
import "fmt"
func selectionsort() {
	arr := [...]int{21, 9, -18, 196 , 88, 68, 1}
	length := len(arr)
	fmt.Printf("原始数组: %v \n",arr)
	for i := 0 ; i < length - 1; i++ {
        // 每次循环时将最小值放在最左边，如 if 条件是 > 则为升序，< 则为降序。
        // 最小数的索引为i
        minIndex := i
		for j := i + 1; j < length; j++ {
			if (arr[minIndex] > arr[j]) {
				minIndex = j
			}
		}
        // 注意其与冒泡排序的不同之处，选择是直接下标交换。
        temp := arr[i]
		arr[i] = arr[minIndex]
		arr[minIndex] = temp 
        
        fmt.Printf("第 %d 次循环: %v\n",i+1,arr)
	}
	fmt.Printf("选择排序: %v",arr)
}

func main(){
  selectionsort()
}


// 原始数组: [21 9 -18 196 88 68 1] 
// 第 1 次循环: [-18 9 21 196 88 68 1]
// 第 2 次循环: [-18 1 21 196 88 68 9]
// 第 3 次循环: [-18 1 9 196 88 68 21]
// 第 4 次循环: [-18 1 9 21 88 68 196]
// 第 5 次循环: [-18 1 9 21 68 88 196]
// 第 6 次循环: [-18 1 9 21 68 88 196]
// 选择排序: [-18 1 9 21 68 88 196]